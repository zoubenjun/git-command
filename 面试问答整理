iOS 中持久化方式有哪些？
NSUserDefaults，归档(序列化)，文件，数据库，CoreData，KeyChain

iOS 什么是ARC？
自动的引用计数（Automatic Reference Count 简称 ARC），是一种内存管理的技术。

iOS 什么是KVO和KVC?他们的使用场景是什么？
KVC是访问对象属性的方法，K即key，V即Value，C是coding系统的编码方式
KVO是注册观察者模式，是一种监听模式
属性赋值，取值，能够监听某个对象属性值的改变。

iOS 通知和协议有哪些不同之处?
1.通知:
通知需要有一个通知中心：NSNotificationCenter，自定义通知的话需要给一个名字，然后监听。
优点:通知的发送者和接受者都不需要知道对方。可以指定接收通知的具体方法。通知名可以是任何字符串。
缺点:较键值观察（KVO）需要多点代码，在删掉前必须移除监听者。
2.协议
通过setDelegate来设置代理对象，最典型的例子是常用的TableView.
优点:支持它的类有详尽和具体信息。
缺点:该类必须支持委托。某一时间只能有一个委托连接到某一对象。

iOS内存的使用和优化的注意事项
重用问题，尽量把views设置为不透明，不要使用太复杂的XIB/Storyboard，选择正确的数据结构，gzip/zip压缩，延迟加载，数据缓存，
处理内存警告(不用资源立即释放掉)，重用大开销对象，避免反复处理数据，使用Autorelease Pool

UIViewController的完整生命周期
-[ViewController initWithNibName:bundle:]；
-[ViewController init]；
-[ViewController loadView]；
-[ViewController viewDidLoad]；
-[ViewController viewWillAppear:]；
-[ViewController viewDidAppear:]；
-[ViewController viewWillDisappear:]；
-[ViewController viewDidDisappear:]；

iOS frame和Bounds 以及frame和bounds区别
1、frame不管对于位置还是大小，改变的都是自己本身
2、frame的位置是以父视图的坐标系为参照，从而确定当前视图在父视图中的位置
3、frame的大小改变时，当前视图的左上角位置不会发生改变，只是大小发生改变
4、bounds改变位置时，改变的是子视图的位置，自身没有影响；其实就是改变了本身的坐标系原点，默认本身坐标系的原点是左上角
5、bounds的大小改变时，当前视图的中心点不会发生改变，当前视图的大小发生改变，看起来效果就想缩放一样

iOS开发中的几种设计模式
代理模式、观察者模式、MVC模式、单例模式、工厂模式、MVVM

解决iOS的cell复用问题
一般情况下应该尽量复用，实在需要不复用可以通过indexPath来创建cell，为每个cell创建唯一的CellIdentifier，把contentView的subViews移除（没有验证过）。

iOS面试题：AFNetworking 底层原理分析
AFNetworking主要是对NSURLSession和NSURLConnection(iOS9.0废弃)的封装,其中主要有以下类:
1). AFHTTPRequestOperationManager：内部封装的是 NSURLConnection, 负责发送网络请求, 使用最多的一个类。(3.0废弃)
2). AFHTTPSessionManager：内部封装是 NSURLSession, 负责发送网络请求,使用最多的一个类。
3). AFNetworkReachabilityManager：实时监测网络状态的工具类。当前的网络环境发生改变之后,这个工具类就可以检测到。
4). AFSecurityPolicy：网络安全的工具类, 主要是针对 HTTPS 服务。
5). AFURLRequestSerialization：序列化工具类,基类。上传的数据转换成JSON格式
(AFJSONRequestSerializer).使用不多。
6). AFURLResponseSerialization：反序列化工具类;基类.使用比较多:
7). AFJSONResponseSerializer; JSON解析器,默认的解析器.
8). AFHTTPResponseSerializer; 万能解析器; JSON和XML之外的数据类型,直接返回二进制数据.对服务器返回的数据不做任何处理.
9). AFXMLParserResponseSerializer; XML解析器;

SDWebImage的缓存策略
SDWebImage 的图片缓存默认情况采用的是 Memory 和 Disk 双重缓存机制。
下载之前先去Memory中查找图片数据，找到直接返回使用；
找不到再到Disk中查找图片数据，找到后放入Memory中再返回使用；
如果Disk中也找不到再去下载图片；
下载到图片后显示图片并将图片数据存到Memory和Disk中。

SDWebImage 加载图片的流程
1、入口 setImageWithURL:placeholderImage:options: 会先把 placeholderImage 显示，然后 SDWebImageManager 根据 URL 开始处理图片。
2、进入 SDWebImageManager-downloadWithURL:delegate:options:userInfo:，交给 SDImageCache 从缓存查找图片是否已经下载 
queryDiskCacheForKey:delegate:userInfo:.
3、先从内存图片缓存查找是否有图片，如果内存中已经有图片缓存，SDImageCacheDelegate 回调 
imageCache:didFindImage:forKey:userInfo: 到 SDWebImageManager。
4、SDWebImageManagerDelegate 回调 webImageManager:didFinishWithImage: 到 UIImageView+WebCache 等前端展示图片。
5、如果内存缓存中没有，生成 NSInvocationOperation 添加到队列开始从硬盘查找图片是否已经缓存。
6、根据 URLKey 在硬盘缓存目录下尝试读取图片文件。这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate:。
7、如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存）。
SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo:。进而回调展示图片。
8、如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片，回调 imageCache:didNotFindImageForKey:userInfo:。
9、共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。
10、图片下载由 NSURLConnection 来做，实现相关 delegate 来判断图片下载中、下载完成和下载失败。
11、connection:didReceiveData: 中利用 ImageIO 做了按图片下载进度加载效果。
12、connectionDidFinishLoading: 数据下载完成后交给 SDWebImageDecoder 做图片解码处理。
13、图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。
14、在主线程 notifyDelegateOnMainThreadWithInfo: 宣告解码完成，imageDecoder:didFinishDecodingImage:userInfo: 
回调给 SDWebImageDownloader。
15、imageDownloader:didFinishWithImage: 回调给 SDWebImageManager 告知图片下载完成。
16、通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。
17、将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。写文件到硬盘也在以单独 NSInvocationOperation 完成，避免拖慢主线程。
18、SDImageCache 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时候清理内存图片缓存，应用结束的时候清理过期图片。
19、SDWI 也提供了 UIButton+WebCache 和 MKAnnotationView+WebCache，方便使用。
20、SDWebImagePrefetcher 可以预先下载图片，方便后续使用

1、SDImageCache是怎么做数据管理的?
SDImageCache分两个部分，一个是内存层面的，一个是硬盘层面的。
内存层面的相当是个缓存器，以Key-Value的形式存储图片。当内存不够的时候会清除所有缓存图片。
用搜索文件系统的方式做管理，文件替换方式是以时间为单位，剔除时间大于一周的图片文件。
当SDWebImageManager向SDImageCache要资源时，先搜索内存层面的数据，如果有直接返回，没有的话去访问磁盘，将图片从磁盘读取出来，
然后做Decoder，将图片对象放到内存层面做备份，再返回调用层。

2、为啥必须做Decoder?
由于UIImage的imageWithData函数是每次画图的时候才将Data解压成ARGB的图像，
所以在每次画图的时候，会有一个解压操作，这样效率很低，但是只有瞬时的内存需求。
为了提高效率通过SDWebImageDecoder将包装在Data下的资源解压，然后画在另外一张图片上，这样这张新图片就不再需要重复解压了。
这种做法是典型的空间换时间的做法。

Runtime在项目中的使用场景：https://blog.csdn.net/SandyLoo/article/details/80174890
做用户埋点统计（我自己的方式是定义basevc，其他vc继承，这样可以直接在basevc去处理）点击事件通过runtime实现，
自定义一个方法替换uicontrol的sendAction:to:forEvent
处理异常崩溃（NSDictionary, NSMutableDictionary,  NSArray, NSMutableArray 的处理）
按钮最小点击区设置
按钮重复点击设置
手势的重复点击处理
UIButton点击事件带多参数
MJRefresh封装
服务端控制页面跳转
字典转模型

